{"version":3,"file":"request.node.js","sourceRoot":"","sources":["../../../src/util/request.node.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Agent as HttpAgent,\n  ClientRequest,\n  ClientRequestArgs,\n  IncomingMessage,\n  request as httpRequest\n} from \"http\";\nimport { Agent as HttpsAgent, request as httpsRequest } from \"https\";\nimport { parse as parseUrl, Url } from \"url\";\nimport { btoa } from \"./btoa\";\nimport { joinPath } from \"./joinPath\";\nimport { Errback } from \"./types\";\n\nexport type ArangojsResponse = IncomingMessage & {\n  request: ClientRequest;\n  body?: any;\n  host?: number;\n};\n\nexport type ArangojsError = Error & {\n  request: ClientRequest;\n};\n\nexport interface RequestOptions {\n  method: string;\n  url: Url;\n  headers: { [key: string]: string };\n  body: any;\n  expectBinary: boolean;\n  timeout?: number;\n}\n\nexport interface RequestFunction {\n  (opts: RequestOptions, cb: Errback<ArangojsResponse>): void;\n  close?: () => void;\n}\n\nexport const isBrowser = false;\n\nexport function createRequest(\n  baseUrl: string,\n  agentOptions: any,\n  agent: any\n): RequestFunction {\n  const baseUrlParts = parseUrl(baseUrl);\n  if (!baseUrlParts.protocol) {\n    throw new Error(`Invalid URL (no protocol): ${baseUrl}`);\n  }\n  const isTls = baseUrlParts.protocol === \"https:\";\n  let socketPath: string | undefined;\n  if (baseUrl.startsWith(`${baseUrlParts.protocol}//unix:`)) {\n    if (!baseUrlParts.pathname) {\n      throw new Error(\n        `Unix socket URL must be in the format http://unix:/socket/path, http+unix:///socket/path or unix:///socket/path not ${baseUrl}`\n      );\n    }\n    const i = baseUrlParts.pathname.indexOf(\":\");\n    if (i === -1) {\n      socketPath = baseUrlParts.pathname;\n      baseUrlParts.pathname = undefined;\n    } else {\n      socketPath = baseUrlParts.pathname.slice(0, i);\n      baseUrlParts.pathname = baseUrlParts.pathname.slice(i + 1) || undefined;\n    }\n  }\n  if (socketPath && !socketPath.replace(/\\//g, \"\").length) {\n    throw new Error(`Invalid URL (empty unix socket path): ${baseUrl}`);\n  }\n  if (!agent) {\n    if (isTls) agent = new HttpsAgent(agentOptions);\n    else agent = new HttpAgent(agentOptions);\n  }\n  return Object.assign(\n    function request(\n      { method, url, headers, body, timeout }: RequestOptions,\n      callback: Errback<ArangojsResponse>\n    ) {\n      let path = baseUrlParts.pathname\n        ? url.pathname\n          ? joinPath(baseUrlParts.pathname, url.pathname)\n          : baseUrlParts.pathname\n        : url.pathname;\n      const search = url.search\n        ? baseUrlParts.search\n          ? `${baseUrlParts.search}&${url.search.slice(1)}`\n          : url.search\n        : baseUrlParts.search;\n      if (search) path += search;\n      if (body && !headers[\"content-length\"]) {\n        headers[\"content-length\"] = String(Buffer.byteLength(body));\n      }\n      if (!headers[\"authorization\"]) {\n        headers[\"authorization\"] = `Basic ${btoa(\n          baseUrlParts.auth || \"root:\"\n        )}`;\n      }\n      const options: ClientRequestArgs = { path, method, headers, agent };\n      if (socketPath) {\n        options.socketPath = socketPath;\n      } else {\n        options.host = baseUrlParts.hostname;\n        options.port = baseUrlParts.port;\n      }\n      let called = false;\n      try {\n        const req = (isTls ? httpsRequest : httpRequest)(\n          options,\n          (res: IncomingMessage) => {\n            const data: Buffer[] = [];\n            res.on(\"data\", chunk => data.push(chunk as Buffer));\n            res.on(\"end\", () => {\n              const result = res as ArangojsResponse;\n              result.request = req;\n              result.body = Buffer.concat(data);\n              if (called) return;\n              called = true;\n              callback(null, result);\n            });\n          }\n        );\n        if (timeout) {\n          req.setTimeout(timeout);\n        }\n        req.on(\"timeout\", () => {\n          req.abort();\n        });\n        req.on(\"error\", err => {\n          const error = err as ArangojsError;\n          error.request = req;\n          if (called) return;\n          called = true;\n          callback(err);\n        });\n        if (body) req.write(body);\n        req.end();\n      } catch (e) {\n        if (called) return;\n        called = true;\n        callback(e);\n      }\n    },\n    {\n      close() {\n        agent.destroy();\n      }\n    }\n  );\n}\n"]}